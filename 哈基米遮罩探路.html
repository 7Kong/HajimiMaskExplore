<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Void Probe - Cyber 2077 Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      background-color: #050505;
      overflow: hidden;
      user-select: none;
    }

    canvas {
      image-rendering: auto;
      cursor: crosshair;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;
    // --- 第三关专用：赛博美术背景逻辑 ---
    const drawLevel3Visuals = (ctx, s, width, height) => {
      // 1. 背景渐变 (深紫到纯黑)
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, '#1a0525');
      grad.addColorStop(1, '#050505');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      // 2. 动态扫描网格
      ctx.save();
      ctx.strokeStyle = 'rgba(188, 0, 255, 0.15)';
      ctx.lineWidth = 1;
      const move = (s.time * 0.5) % 40;
      for (let x = 0; x < width; x += 40) {
        ctx.beginPath(); ctx.moveTo(x + move, 0); ctx.lineTo(x + move, height); ctx.stroke();
      }
      for (let y = 0; y < height; y += 40) {
        ctx.beginPath(); ctx.moveTo(0, y + move); ctx.lineTo(width, y + move); ctx.stroke();
      }
      ctx.restore();

      // 3. 随机闪烁的故障装饰条 (Glitch Lines)
      for (let i = 0; i < 8; i++) {
        const seed = Math.sin(Math.floor(s.time / 15) + i) * 100;
        if (seed > 0.5) {
          ctx.fillStyle = i % 2 === 0 ? 'rgba(0, 255, 255, 0.2)' : 'rgba(188, 0, 255, 0.2)';
          ctx.fillRect((seed * 123) % width, (seed * 456) % height, 150, 1);
        }
      }

      // 4. 背景能量碎片 (向上漂浮)
      ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
      for (let i = 0; i < 20; i++) {
        const px = (Math.sin(i * 99) * 0.5 + 0.5) * width;
        const py = (height - (s.time * (1 + i % 3) + i * 50) % height);
        ctx.fillRect(px, py, 2, 2);
        if (i % 5 === 0) { // 给部分碎片加连线
          ctx.strokeStyle = "rgba(0, 255, 255, 0.1)";
          ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + 40, py + 40); ctx.stroke();
        }
      }
    };

    const LEVEL_CONFIG = {
      spawn: { x: 40, y: 440 },
      goal: { x: 740, y: 260, width: 40, height: 40 },
      staticRects: [[0, 15, 23, 29, true], [27, 28, 8, 25, false], [35, 45, 20, 21, true], [55, 60, 15, 29, true]],
      patrols: [{ baseX: 400, y: 410, range: 120, speed: 0.01, width: 120, height: 30 }],
      ornaments: [[140, 200, 60], [220, 200, 90], [300, 180, 50], [600, 280, 80], [680, 280, 50]],
      physics: { gravity: 0.18, jumpForce: -6.5, moveAccel: 0.4, probeSpeed: 9, maxProbes: 3 }
    };

    const LEVEL_CONFIGS = {
      1: {
        spawn: { x: 40, y: 440 },
        goal: { x: 740, y: 260, width: 40, height: 40 },
        staticRects: [[0, 15, 23, 29, true], [27, 28, 8, 25, false], [35, 45, 20, 21, true], [55, 60, 15, 29, true]],
        patrols: [{ baseX: 400, y: 410, range: 120, speed: 0.01, width: 120, height: 30 }],
        ornaments: [[140, 200, 60], [220, 200, 90], [300, 180, 50], [600, 280, 80], [680, 280, 50]],
        physics: {
          gravity: 0.18,
          jumpForce: -6.5,
          moveAccel: 0.4,
          probeSpeed: 9,
          maxProbes: 3,
          enableDoubleJump: false // <--- [新增] 第一关关闭二段跳
        }
      },
      2: {
        spawn: { x: 40, y: 500 },
        goal: { x: 740, y: 80, width: 40, height: 40 },
        staticRects: [
          [0, 10, 27, 29, true],
          [20, 21, 13, 34, false], // 你刚才修改的高墙
          [28, 35, 20, 21, true],//放置技能道具的平台
          [45, 46, 5, 20, false],
          [55, 65, 12, 13, true],
          [70, 75, 10, 20, false]
        ],
        patrols: [
          { baseX: 250, y: 350, range: 100, speed: 0.01, width: 80, height: 40 },
          { baseX: 550, y: 180, range: 120, speed: 0.01, width: 80, height: 40 }
        ],
        ornaments: [[300, 150, 80], [500, 200, 60]],
        physics: {
          gravity: 0.18,
          jumpForce: -6.5,
          moveAccel: 0.4,
          probeSpeed: 9,
          maxProbes: 3,
          enableDoubleJump: true // <--- [新增] 第二关开启二段跳
        }
      },
      3: {
        spawn: { x: 40, y: 500 },
        goal: { x: 740, y: 80, width: 40, height: 40 },
        staticRects: [
          [0, 10, 27, 29, true], [20, 21, 13, 34, false], [28, 35, 20, 21, true],
          [45, 46, 5, 20, false], [55, 65, 12, 13, true], [70, 75, 10, 20, false]
        ],
        patrols: [
          { baseX: 250, y: 350, range: 100, speed: 0.01, width: 80, height: 40 },
          { baseX: 550, y: 180, range: 120, speed: 0.01, width: 80, height: 40 }
        ],
        ornaments: [[300, 150, 80], [500, 200, 60]],
        physics: {
          gravity: 0.18, jumpForce: -6.5, moveAccel: 0.4, probeSpeed: 9, maxProbes: 5, enableDoubleJump: false // <--- [新增] 第三关关闭二段跳
        }
      }
    };

    const TILE_SIZE = 20;
    const LIGHT_RADIUS = 180;
    const PURPLE_LIGHT_RADIUS = 270;
    const CANVAS_WIDTH = 1920;
    const CANVAS_HEIGHT = 1080;

    const App = () => {
      const canvasRef = useRef(null);
      const [probeCount, setProbeCount] = useState(0);
      const [hasWon, setHasWon] = useState(false);

      const sounds = useRef({
        shoot: Object.assign(new Audio('xm2957.wav'), { preload: 'auto' }),
        hit: Object.assign(new Audio('xm3157.wav'), { preload: 'auto' }),
        death: Object.assign(new Audio('xm3633.wav'), { preload: 'auto' }),
        respawn: Object.assign(new Audio('角色复活音.wav'), { preload: 'auto' }),
        land: Object.assign(new Audio('跳跃落地声.wav'), { preload: 'auto' }),
        ding: Object.assign(new Audio('xm3157.wav'), { preload: 'auto' }),
      });

      const state = useRef({
        blocks: [], patrols: [], probes: [], particles: [], ornaments: [], grasses: [],
        player: {
          ...LEVEL_CONFIG.spawn, vx: 0, vy: 0, width: 20, height: 20, isGrounded: false, scaleX: 1, scaleY: 1, canDoubleJump: true,
          trail: [], // <--- [新增] 用于存储猫猫最近的移动轨迹
          trailTimer: 0 // <--- [新增] 飘带剩余显示时间（帧数）
        },
        keys: { up: false, left: false, right: false },
        time: 0, shake: 0, level: 1
      });

      const triggerEffect = (name, vol = 0.5, shake = 0) => {
        const s = sounds.current[name];
        if (s) { s.currentTime = 0; s.volume = vol; s.play().catch(() => { }); }
        if (shake > 0) state.current.shake = shake;
      };

      const checkAABB = (r1, r2) => (r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y);
      const getDist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

      const drawSecondLevelBackground = (ctx, s, width, height) => {
        // 径向渐变覆盖全屏
        const bgGrad = ctx.createRadialGradient(width / 2, height / 2, 100, width / 2, height / 2, width / 1.2);
        bgGrad.addColorStop(0, '#1a0510');
        bgGrad.addColorStop(1, '#050505');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        ctx.save();
        ctx.strokeStyle = '#2a0a25';
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.globalAlpha = 0.3;
        // 增加循环次数从 5 变为 12，确保铺满 1920 宽度
        for (let i = 0; i < 12; i++) {
          const offset = Math.sin(s.time * 0.02 + i) * 20;
          ctx.beginPath();
          ctx.moveTo(i * 200 - 200, height + 50); // 稍微向左偏移起始点
          ctx.bezierCurveTo(i * 200 + offset, height - 100, i * 200 - offset, 300, i * 200 + 100, -100);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = 'rgba(255, 100, 200, 0.1)';
        ctx.lineWidth = 1;
        // 网格线铺满全屏
        for (let i = 0; i < width; i += 80) {
          ctx.beginPath();
          ctx.moveTo(i, height);
          ctx.lineTo(i + 40, 0);
          ctx.stroke();
        }
        ctx.restore();

        // 粒子生成范围扩大到全屏
        if (s.time % 10 === 0) {
          s.particles.push({
            x: Math.random() * width, y: -10,
            vx: (Math.random() - 0.5) * 1, vy: 1 + Math.random(),
            life: 1, color: Math.random() > 0.5 ? '#ffb7c5' : '#e0bbff',
            type: 'petal'
          });
        }
      };

      useEffect(() => {
        const config = LEVEL_CONFIGS[state.current.level];
        const blocks = [];
        const grasses = [];
        config.staticRects.forEach(([cS, cE, rS, rE, perm]) => {
          for (let r = rS; r <= rE; r++) {
            for (let c = cS; c <= cE; c++) {
              const b = { x: c * TILE_SIZE, y: r * TILE_SIZE, alpha: 0, scale: 0, isPermanent: !!perm, seed: Math.random() };
              blocks.push(b);
              if (perm && r === rS) {
                for (let i = 0; i < 2; i++) {
                  grasses.push({
                    x: b.x + Math.random() * 20, y: b.y,
                    height: 6 + Math.random() * 10,
                    angle: 0, targetAngle: 0,
                    color: Math.random() > 0.5 ? '#3d634d' : '#4d8a63'
                  });
                }
              }
            }
          }
        });
        state.current.blocks = blocks;
        state.current.grasses = grasses;
        state.current.patrols = config.patrols.map(p => ({ ...p, alpha: 0, x: p.baseX }));
        state.current.ornaments = config.ornaments.map(([ax, ay, len]) => ({
          anchorX: ax, anchorY: ay, length: len, x: ax, y: ay + len, vx: 0, vy: 0, size: 12
        }));
      }, [state.current.level]);

      useEffect(() => {
        const ctx = canvasRef.current.getContext('2d');
        let frame;

        const update = () => {
          const s = state.current;
          const config = LEVEL_CONFIGS[s.level];
          const { gravity, jumpForce, moveAccel } = config.physics;
          s.time++;
          setProbeCount(s.probes.length);
          if (s.shake > 0) s.shake *= 0.9;

          if (!hasWon) {
            // --- 在 update 函数内部插入 ---
            s.probes = s.probes.filter(pr => {
              if (pr.isExpiring) {
                pr.life--;
                return pr.life > 0; // 只要生命值还大于 0，就保留；否则滤掉
              }
              return true; // 没有标签的新子弹永远保留
            });
            s.probes.forEach(p => {
              if (p.stuck) return;
              p.vy += 0.1; p.x += p.vx; p.y += p.vy;

              if (s.time % 2 === 0) s.particles.push({ x: p.x, y: p.y, life: 1, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), color: '#fd0', type: 'smoke' });
              [...s.blocks, ...s.patrols].forEach(obj => {
                const rect = { x: obj.x || obj.baseX, y: obj.y, width: obj.width || 20, height: obj.height || 20 };
                if (p.x > rect.x && p.x < rect.x + rect.width && p.y > rect.y && p.y < rect.y + rect.height) { p.stuck = true; triggerEffect('hit', 0.3, 3); }
              });
            });

            // 2. 找到处理玩家 p 的位置 (大约在 p.y += p.vy 之后)
            const p = s.player;

            // --- [核心修改] 飘带计时与记录逻辑 ---
            if (p.trailTimer > 0) {
              p.trailTimer--; // 计时器倒计时

              // 记录轨迹点
              p.trail.push({ x: p.x + 10, y: p.y + 10 });

              // 轨迹长度可以稍微加长到 25，增加视觉张力
              if (p.trail.length > 25) p.trail.shift();
            } else {
              // 计时器结束，逐渐清空旧轨迹，产生慢慢缩短消失的效果
              if (p.trail.length > 0) p.trail.shift();
            }
            if (s.keys.left) p.vx -= moveAccel; if (s.keys.right) p.vx += moveAccel;
            p.vx *= 0.88; p.x += p.vx;
            const colliders = [...s.blocks, ...s.patrols].filter(o => o.alpha > 0.4 || o.isPermanent);
            colliders.forEach(o => {
              const r = { x: o.x, y: o.y, width: o.width || 20, height: o.height || 20 };
              if (p.x < r.x + r.width && p.x + p.width > r.x && p.y < r.y + r.height && p.y + p.height > r.y) { p.vx > 0 ? p.x = r.x - p.width : p.x = r.x + r.width; p.vx = 0; }
            });
            p.vy += gravity; p.y += p.vy;
            // [修正] 将记录逻辑放在这里，确保记录的是玩家 p 的位置
            if (Math.hypot(p.vx, p.vy) > 2) {
              p.trail.push({ x: p.x + 10, y: p.y + 10, life: 1.0 });
            }
            if (p.trail.length > 15) p.trail.shift();
            p.trail.forEach(t => t.life -= 0.05);
            p.trail = p.trail.filter(t => t.life > 0);
            const wasG = p.isGrounded; p.isGrounded = false;
            colliders.forEach(o => {
              const r = { x: o.x, y: o.y, width: o.width || 20, height: o.height || 20 };
              if (p.x < r.x + r.width && p.x + p.width > r.x && p.y < r.y + r.height && p.y + p.height > r.y) {
                if (p.vy > 0) { p.y = r.y - p.height; p.isGrounded = true; p.scaleX = 1.3; p.scaleY = 0.7; } else { p.y = r.y + r.height; }
                p.vy = 0;
              }
            });
            if (p.isGrounded && !wasG) triggerEffect('land', 0.15, 1);
            // 落地重置二段跳
            if (p.isGrounded) {
              p.canDoubleJump = true;
            }

            // --- 找到 if (s.keys.up) 部分进行修改 ---
            if (s.keys.up) {
              if (p.isGrounded) {
                p.vy = jumpForce;
                p.scaleX = 0.7; p.scaleY = 1.3;
                s.keys.up = false;
              }
              // 关键修改点在这里：增加 config.physics.enableDoubleJump 判定
              else if (config.physics.enableDoubleJump && p.canDoubleJump) {
                p.canDoubleJump = false;
                p.trailTimer = 180; // <--- [在这里插入这一行] 开启 3 秒的飘带计时

                // 计算逻辑坐标系下的鼠标位置并施加力
                const offsetX = (CANVAS_WIDTH - 800) / 2;
                const offsetY = (CANVAS_HEIGHT - 600) / 2;
                const dx = (s.mouseX - offsetX) - (p.x + 10);
                const dy = (s.mouseY - offsetY) - (p.y + 10);
                const dist = Math.hypot(dx, dy) || 1;

                const force = 8;
                p.vx = -(dx / dist) * force;
                p.vy = -(dy / dist) * force;

                p.scaleX = 1.5; p.scaleY = 0.6;
                triggerEffect('shoot', 0.6, 6);


                // --- 赛博长条拖尾粒子生成 ---
                for (let i = 0; i < 25; i++) {
                  const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4;
                  const speed = Math.random() * 12 + 4; // 稍微提高速度，让拖尾更长

                  s.particles.push({
                    x: p.x + 10,
                    y: p.y + 10,
                    life: 1.0,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: Math.random() > 0.3 ? '#00f7ff' : '#ffffff',
                    type: 'trail' // 注意：我们将 type 改为 'trail'
                  });
                }

                // 额外添加一个小冲击波环
                for (let i = 0; i < 8; i++) {
                  s.particles.push({
                    x: p.x + 10, y: p.y + 10, life: 0.8,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: '#ff00ff', // 冲击波带一点霓虹紫
                    type: 'smoke'
                  });
                }
                s.keys.up = false;
              }
            }
            p.scaleX += (1 - p.scaleX) * 0.2; p.scaleY += (1 - p.scaleY) * 0.2;

            if (p.y > CANVAS_HEIGHT + 100) { triggerEffect('death', 0.5, 8); Object.assign(p, { ...config.spawn, vx: 0, vy: 0 }); }
            if (checkAABB(p, config.goal)) { setHasWon(true); triggerEffect('respawn', 0.8); }

            s.ornaments.forEach(orn => {
              orn.vy += gravity * 0.5; orn.x += orn.vx; orn.y += orn.vy;
              const dx = orn.x - orn.anchorX; const dy = orn.y - orn.anchorY; const dist = Math.hypot(dx, dy);
              if (dist > orn.length) {
                const ratio = orn.length / dist; orn.x = orn.anchorX + dx * ratio; orn.y = orn.anchorY + dy * ratio;
                const nx = dx / dist; const ny = dy / dist; const vDotN = orn.vx * nx + orn.vy * ny;
                orn.vx -= nx * vDotN * 0.1; orn.vy -= ny * vDotN * 0.1;
              }
              orn.vx *= 0.98; orn.vy *= 0.98;
              if (getDist(p.x + 10, p.y + 10, orn.x, orn.y) < (orn.size / 2 + 10)) {
                orn.vx += p.vx * 0.8; orn.vy += p.vy * 0.8;
                if (Math.abs(p.vx) > 1) triggerEffect('ding', 0.1);
              }
            });



            s.grasses.forEach(g => {
              g.targetAngle = Math.sin(s.time * 0.05 + g.x) * 0.1;
              if (Math.abs(p.x + 10 - g.x) < 15 && Math.abs(p.y + 10 - g.y) < 20) {
                g.targetAngle = p.vx * 0.6;
              }
              g.angle += (g.targetAngle - g.angle) * 0.15;
            });
          }

          s.patrols.forEach(m => {
            const sinVal = Math.sin(s.time * 0.01);
            m.x = m.baseX + (Math.max(-0.8, Math.min(0.8, sinVal)) / 0.8) * m.range;
            const isLit = s.probes.some(p => Math.hypot(m.x + m.width / 2 - p.x, m.y + m.height / 2 - p.y) < PURPLE_LIGHT_RADIUS);
            m.alpha += ((isLit ? 1 : 0) - m.alpha) * 0.1;
          });
          s.blocks.forEach(b => {
            const lit = b.isPermanent || s.probes.some(p => Math.hypot(b.x + 10 - p.x, b.y + 10 - p.y) < LIGHT_RADIUS);
            b.alpha += ((lit ? 1 : 0) - b.alpha) * 0.1;
            b.scale += ((lit ? 1 : 0) - b.scale) * 0.15;
          });

          ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          // 1. 渲染背景
          if (s.level === 3) {
            // 注意这里要把 state.current 传进去给 s
            drawLevel3Visuals(ctx, state.current, CANVAS_WIDTH, CANVAS_HEIGHT);
          } else if (s.level === 2) {
            drawSecondLevelBackground(ctx, state.current, CANVAS_WIDTH, CANVAS_HEIGHT);
          } else {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          }

          // >>> 粘贴在这里 START <<<
          ctx.save();
          ctx.globalAlpha = 0.05;
          ctx.fillStyle = 'white';
          for (let i = 0; i < CANVAS_HEIGHT; i += 4) {
            ctx.fillRect(0, i, CANVAS_WIDTH, 1);
          }
          ctx.restore();
          // >>> 粘贴在这里 END <<<

          // 2. 进入居中坐标系渲染游戏主体
          ctx.save();
          const offsetX = (CANVAS_WIDTH - 800) / 2;
          const offsetY = (CANVAS_HEIGHT - 600) / 2;
          ctx.translate(offsetX, offsetY);


          if (s.shake > 1) ctx.translate((Math.random() - 0.5) * s.shake, (Math.random() - 0.5) * s.shake);

          s.blocks.forEach(b => {
            if (b.alpha < 0.01) return;
            ctx.save(); ctx.globalAlpha = b.alpha;
            if (b.isPermanent) {
              ctx.fillStyle = '#16221d'; ctx.fillRect(b.x, b.y, 20, 20);
              ctx.strokeStyle = '#2d4d3d'; ctx.lineWidth = 1; ctx.strokeRect(b.x + 0.5, b.y + 0.5, 19, 19);
              ctx.strokeStyle = '#0a1410'; ctx.beginPath();
              if (b.seed > 0.5) { ctx.moveTo(b.x, b.y + 10); ctx.lineTo(b.x + 20, b.y + 10); }
              else { ctx.moveTo(b.x + 10, b.y); ctx.lineTo(b.x + 10, b.y + 20); }
              ctx.stroke();
            } else {
              const x = b.x, y = b.y, seed = b.seed;
              const t = s.time;
              ctx.fillStyle = '#05111a';
              ctx.fillRect(x, y, 20, 20);
              ctx.lineWidth = 1;
              ctx.strokeStyle = `rgba(0, 247, 255, ${0.15 + Math.sin(t * 0.1 + seed * 10) * 0.1})`;
              ctx.beginPath();
              if (seed < 0.25) {
                ctx.moveTo(x + 10, y); ctx.lineTo(x + 10, y + 20);
                ctx.moveTo(x, y + 10); ctx.lineTo(x + 20, y + 10);
              } else if (seed < 0.5) {
                ctx.moveTo(x + 5, y); ctx.lineTo(x + 5, y + 15); ctx.lineTo(x + 20, y + 15);
              } else if (seed < 0.75) {
                ctx.strokeRect(x + 4, y + 4, 12, 12);
              } else {
                ctx.moveTo(x, y + 5); ctx.lineTo(x + 15, y + 20);
                ctx.moveTo(x + 5, y); ctx.lineTo(x + 20, y + 15);
              }
              ctx.stroke();
              ctx.fillStyle = 'rgba(0, 247, 255, 0.2)';
              for (let i = 0; i < 3; i++) {
                const px = ((seed * (i + 1) * 13) % 14) + 3;
                const py = ((seed * (i + 1) * 17) % 14) + 3;
                ctx.fillRect(x + px, y + py, 1.5, 1.5);
              }
              if (seed > 0.7) {
                const flicker = Math.sin(t * 0.15 + seed * 50) > 0.8 ? 0.9 : 0.2;
                ctx.fillStyle = `rgba(0, 247, 255, ${flicker})`;
                ctx.fillRect(x + 15, y + 3, 2, 2);
              }
              ctx.strokeStyle = 'rgba(0, 247, 255, 0.4)';
              ctx.strokeRect(x + 0.5, y + 0.5, 19, 19);
              ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
              for (let i = 3; i < 18; i += 5) ctx.fillRect(x + 2, y + i, 16, 1);
              if (b.alpha > 0.8) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00f7ff';
                ctx.strokeStyle = 'rgba(0, 247, 255, 0.3)';
                ctx.strokeRect(x + 2, y + 2, 16, 16);
              }
            }
            ctx.restore();
          });

          s.patrols.forEach(m => {
            if (m.alpha < 0.01) return;
            ctx.save();
            ctx.globalAlpha = m.alpha;

            const t = s.time;
            const x = m.x, y = m.y, w = m.width, h = m.height;

            // 1. 底层深色外壳 + 强力霓虹外发光
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#aa00ff';
            ctx.fillStyle = '#0a020c';
            ctx.fillRect(x, y, w, h);
            ctx.shadowBlur = 0; // 关闭阴影，避免影响后续性能

            // 2. 绘制动态背景流光 (斜向扫描线)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip(); // 限制流光只在方块内部
            ctx.strokeStyle = 'rgba(170, 0, 255, 0.2)';
            ctx.lineWidth = 2;
            for (let i = 0; i < w + h; i += 10) {
              const move = (t % 20); // 随时间移动
              ctx.beginPath();
              ctx.moveTo(x + i - move, y);
              ctx.lineTo(x + i - move - 10, y + h);
              ctx.stroke();
            }
            ctx.restore();

            // 3. 核心能量槽 (中间的亮紫色细条)
            const pulse = Math.sin(t * 0.1) * 0.3 + 0.7; // 呼吸灯效果
            ctx.fillStyle = `rgba(170, 0, 255, ${pulse})`;
            ctx.fillRect(x + 5, y + h / 2 - 1, w - 10, 2);

            // 4. 四角强化装饰 (L型护角)
            ctx.strokeStyle = '#df00ff';
            ctx.lineWidth = 3;
            const cornerSize = 8;
            // 左上
            ctx.beginPath(); ctx.moveTo(x, y + cornerSize); ctx.lineTo(x, y); ctx.lineTo(x + cornerSize, y); ctx.stroke();
            // 右下
            ctx.beginPath(); ctx.moveTo(x + w, y + h - cornerSize); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - cornerSize, y + h); ctx.stroke();

            // 5. 顶部电子字符颗粒 (模拟数据流)
            ctx.fillStyle = '#ff00ff';
            for (let i = 0; i < 2; i++) {
              const dotX = x + ((t * (i + 1) * 2) % w);
              ctx.fillRect(dotX, y + 2, 3, 1.5);
            }

            // 6. 最终边框
            ctx.strokeStyle = 'rgba(170, 0, 255, 0.8)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

            ctx.restore();
          });
          s.grasses.forEach(g => {
            ctx.save(); ctx.translate(g.x, g.y); ctx.rotate(g.angle);
            ctx.strokeStyle = g.color; ctx.lineWidth = 2; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(2, -g.height / 2, 0, -g.height); ctx.stroke();
            ctx.restore();
          });


          // --- 渲染终点 Artifact ---
          const goal = config.goal;
          ctx.save();
          ctx.translate(goal.x + goal.width / 2, goal.y + goal.height / 2);
          ctx.shadowBlur = 20; ctx.shadowColor = '#4db6ac'; ctx.fillStyle = '#1a2e2a';
          ctx.fillRect(-goal.width / 2, -goal.height / 2, goal.width, goal.height);
          ctx.strokeStyle = '#c5a059'; ctx.lineWidth = 2;
          ctx.strokeRect(-goal.width / 2 + 4, -goal.height / 2 + 4, goal.width - 8, goal.height - 8);
          ctx.beginPath(); ctx.arc(-6, -5, 3, 0, 7); ctx.arc(6, -5, 3, 0, 7); ctx.stroke();
          if (s.time % 5 === 0) {
            s.particles.push({
              x: goal.x + Math.random() * goal.width, y: goal.y + goal.height,
              life: 1, vx: 0, vy: -0.6, color: '#00ffcc', type: 'fire'
            });
          }
          ctx.restore();

          s.ornaments.forEach(orn => {
            ctx.strokeStyle = '#555'; ctx.beginPath(); ctx.moveTo(orn.anchorX, orn.anchorY); ctx.lineTo(orn.x, orn.y); ctx.stroke();
            ctx.save(); ctx.translate(orn.x, orn.y); ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff'; ctx.fillStyle = '#e0ffff';
            ctx.beginPath(); ctx.arc(0, 0, orn.size / 2, 0, 7); ctx.fill(); ctx.restore();
          });

          s.probes.forEach(pr => {
            ctx.save();

            // 计算透明度系数
            // 如果是带标签的旧子弹，透明度 = 剩余生命 / 总生命
            // 如果是新子弹，透明度 = 1
            const fade = pr.isExpiring ? (pr.life / 180) : 1;

            // 在所有绘图属性前加上这个系数
            ctx.globalAlpha = 0.4 * fade;
            ctx.strokeStyle = '#bc00ff';

            // --- 1. 强化紫色范围边缘 ---
            ctx.globalAlpha = 0.4;          // [修改] 提高透明度，从 0.15 提升到 0.6
            ctx.strokeStyle = '#bc00ff';    // [修改] 使用更亮的紫色
            ctx.lineWidth = 2;              // [新增] 增加线宽
            ctx.setLineDash([8, 4]);        // [修改] 调整虚线比例，让实线部分更长

            // [新增] 为边缘添加霓虹发光，这是在第二关看清它的关键
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#bc00ff';

            ctx.beginPath();
            ctx.arc(pr.x, pr.y, PURPLE_LIGHT_RADIUS, 0, 7);
            ctx.stroke();

            // --- 2. 内部黄色光晕 (保持原样或轻微调整) ---
            ctx.restore(); // 先恢复一次状态，清除上面的发光和虚线设置

            ctx.save();
            ctx.globalAlpha = 0.08;         // 稍微提高一点点内部填充感
            ctx.fillStyle = '#fd0';
            ctx.beginPath();
            ctx.arc(pr.x, pr.y, LIGHT_RADIUS, 0, 7);
            ctx.fill();
            ctx.restore();

            // --- 3. 子弹核心实体 ---
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fd0';
            ctx.fillStyle = '#fd0';
            ctx.beginPath();
            ctx.arc(pr.x, pr.y, 4, 0, 7);
            ctx.fill();
          });

          // --- 先定义玩家常量，再进行渲染 ---
          const p_c = s.player;

          // --- 渲染飘带 (Motion Ribbon) ---
          if (p_c.trail && p_c.trail.length > 2) {
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00f7ff';

            // 遍历轨迹点，每一段单独绘制以改变宽度
            for (let i = 0; i < p_c.trail.length - 1; i++) {
              const p1 = p_c.trail[i];
              const p2 = p_c.trail[i + 1];

              // 计算进度比例 (从 0 到 1)
              const progress = i / p_c.trail.length;

              // --- 关键算法 ---
              // 1. 宽度随进度增加：头部(最新)最宽，尾部最细
              ctx.lineWidth = 1 + progress * 5;

              // 2. 透明度随进度增加：头部最亮，尾部最淡
              ctx.globalAlpha = progress * 0.6;

              ctx.beginPath();
              ctx.strokeStyle = '#00f7ff';
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
            ctx.restore();
          }

          // --- 渲染玩家猫猫 ---
          ctx.save();
          ctx.translate(p_c.x + 10, p_c.y + 20);
          ctx.scale(p_c.scaleX, p_c.scaleY);
          ctx.fillStyle = '#ffdb4d'; ctx.shadowBlur = 15; ctx.shadowColor = '#ffcc00';
          ctx.beginPath(); ctx.roundRect(-10, -20, 20, 20, [4, 4, 2, 2]); ctx.fill();
          ctx.beginPath(); ctx.moveTo(-10, -20); ctx.lineTo(-10, -26); ctx.lineTo(-4, -20); ctx.moveTo(10, -20); ctx.lineTo(10, -26); ctx.lineTo(4, -20); ctx.fill();
          const isBlinking = s.time % 140 > 135; const eyeX = p_c.vx * 1.2;
          ctx.fillStyle = isBlinking ? '#420' : '#fff'; ctx.fillRect(-7 + eyeX, -14, 4, 4); ctx.fillRect(3 + eyeX, -14, 4, 4);
          ctx.save(); ctx.translate(-8, -4); ctx.rotate(Math.sin(s.time * 0.1) * 0.5 + (p_c.vy * 0.1)); ctx.fillStyle = '#ffdb4d'; ctx.fillRect(-8, -2, 8, 3); ctx.restore();
          ctx.restore();

          s.particles.forEach(pt => {
            ctx.save();
            ctx.globalAlpha = pt.life;
            ctx.fillStyle = pt.color;
            ctx.shadowBlur = 5; // 赋予发光感
            ctx.shadowColor = pt.color;

            if (pt.type === 'trail') {
              // --- 渲染长条拖尾 ---
              const trailLength = 2.5; // 长度倍率
              ctx.strokeStyle = pt.color;
              ctx.lineWidth = 2;
              ctx.lineCap = 'round';
              ctx.beginPath();
              ctx.moveTo(pt.x, pt.y);
              // 根据速度矢量画出一条反向的线，形成拖尾视觉
              ctx.lineTo(pt.x - pt.vx * trailLength, pt.y - pt.vy * trailLength);
              ctx.stroke();
            } else {
              // 普通粒子渲染
              ctx.fillRect(pt.x, pt.y, 2, 2);
            }

            ctx.restore();

            // 物理更新
            pt.x += pt.vx;
            pt.y += pt.vy;
            pt.life -= 0.025; // 稍微加快消失速度，让效果更干脆
          });
          s.particles = s.particles.filter(pt => pt.life > 0);

          ctx.restore();
          frame = requestAnimationFrame(update);
        };
        frame = requestAnimationFrame(update);
        return () => cancelAnimationFrame(frame);
      }, [hasWon]);

      useEffect(() => {
        const canvas = canvasRef.current;

        // 统一的坐标转换函数
        const updateMousePos = (e) => {
          const s = state.current;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          s.mouseX = (e.clientX - rect.left) * scaleX;
          s.mouseY = (e.clientY - rect.top) * scaleY;
        };

        const hKD = (e) => {
          if (hasWon) return;
          const k = e.key.toLowerCase();
          if (k === 'w' || k === ' ') state.current.keys.up = true;
          if (k === 'a') state.current.keys.left = true;
          if (k === 'd') state.current.keys.right = true;
        };

        const hKU = (e) => {
          const k = e.key.toLowerCase();
          if (k === 'w' || k === ' ') state.current.keys.up = false;
          if (k === 'a') state.current.keys.left = false;
          if (k === 'd') state.current.keys.right = false;
        };

        const mD = (e) => {
          if (hasWon) return;
          updateMousePos(e); // 点击时先更新位置
          const s = state.current;
          const offsetX = (CANVAS_WIDTH - 800) / 2;
          const offsetY = (CANVAS_HEIGHT - 600) / 2;

          const dx = (s.mouseX - offsetX) - (s.player.x + 10);
          const dy = (s.mouseY - offsetY) - (s.player.y + 10);
          const ang = Math.atan2(dy, dx);

          s.probes = [...s.probes, {
            x: s.player.x + 10, y: s.player.y + 10,
            vx: Math.cos(ang) * 9, vy: Math.sin(ang) * 9,
            stuck: false
          }].slice(-3);
          triggerEffect('shoot', 0.4, 2);
        };

        const mM = (e) => updateMousePos(e); // 实时监听鼠标移动

        window.addEventListener('keydown', hKD);
        window.addEventListener('keyup', hKU);
        window.addEventListener('mousedown', mD);
        window.addEventListener('mousemove', mM); // 注册移动监听

        return () => {
          window.removeEventListener('keydown', hKD);
          window.removeEventListener('keyup', hKU);
          window.removeEventListener('mousedown', mD);
          window.removeEventListener('mousemove', mM);
        };
      }, [hasWon]);
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-[#050505] text-white font-mono relative">
          {hasWon && (
            <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-md">
              <div className="text-center p-12 border-y-2 border-yellow-500 bg-black/80">

                <h2 className="text-7xl font-black text-yellow-400 mb-2 italic">哈基米南北路多~</h2>
                {/* --- [新增] 只有在第一关过关后（即进入第二关前）显示此提示 --- */}
                {state.current.level === 1 && (
                  <div className="mb-6 p-4 border-l-4 border-cyan-500 bg-cyan-950/30 text-cyan-400 text-left max-w-xl mx-auto animate-pulse">
                    <p className="text-lg font-bold">系统提示：[解锁新模组 - 矢量喷射]</p>
                    <p className="text-sm opacity-90">
                      你学会了<span className="text-white font-bold">二段跳</span>。
                      弹射方向是鼠标位置的<span className="text-yellow-400 font-bold">反方向</span>。
                      利用此动能冲破高墙。
                    </p>
                  </div>
                )}
                {/* 第二关结束：提示回归原始跳跃 */}
                {state.current.level === 2 && (
                  <div className="mb-6 mt-4 p-4 border-l-4 border-red-500 bg-red-900/20 text-red-400 text-left max-w-lg mx-auto">
                    <p className="text-lg font-bold text-white">警报：高能干扰，二段跳模组失效！</p>
                    <p className="text-sm">请用<span className="text-yellow-400 font-bold">一段跳跃</span>通关此关卡吧。子弹已修改成<span className="text-yellow-400 font-bold">5颗!!</span></p>
                  </div>
                )}

                <div className="flex gap-4 justify-center mt-6">
                  {/* 如果不是第三关，显示正常的下一关按钮 */}
                  {state.current.level < 3 ? (
                    // --- 找到 NEXT_LEVEL 按钮的 onClick 处替换 ---
                    <button onClick={() => {
                      // 1. 先给“上一关”留下的所有子弹打上报废标签
                      state.current.probes.forEach(p => {
                        p.isExpiring = true;
                        p.life = 180; // 这里的 180 就是 3 秒（60帧/秒）
                      });

                      // 2. 正常切换关卡
                      state.current.level++;
                      const currentConfig = LEVEL_CONFIGS[state.current.level] || LEVEL_CONFIGS[1];
                      Object.assign(state.current.player, { ...currentConfig.spawn, vx: 0, vy: 0 });

                      setHasWon(false);
                      setProbeCount(0); // 这里的 0 是重置左下角的可用子弹槽，不影响场上的子弹
                    }} className="px-12 py-4 border border-cyan-400 text-cyan-400 hover:bg-cyan-400 hover:text-black transition-all">
                      NEXT_LEVEL
                    </button>
                  ) : (
                    /* 如果是第三关，显示感谢语和特定选项 */
                    <div className="flex flex-col items-center gap-4">
                      <p className="text-white text-xl font-bold animate-bounce mb-2">✨ 谢谢你游玩这个游戏 ✨</p>
                      <div className="flex gap-4">
                        <button onClick={() => {
                          // 重玩本关（第三关）
                          const currentConfig = LEVEL_CONFIGS[3];
                          Object.assign(state.current.player, { ...currentConfig.spawn, vx: 0, vy: 0 });
                          setHasWon(false);
                          setProbeCount(0);
                        }} className="px-6 py-3 border border-purple-500 text-purple-400 hover:bg-purple-500 hover:text-black">
                          重玩本关
                        </button>
                        <button onClick={() => window.location.reload()} className="px-6 py-3 border border-yellow-500 text-yellow-500 hover:bg-yellow-500 hover:text-black">
                          回第一关
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
          {/* 让 UI 的宽度匹配 1920 画布宽度 */}
          <div style={{ width: '1920px' }} className="z-10 flex justify-between items-end mb-4 px-10 opacity-60">
            <h1 className="text-2xl font-black text-yellow-500 italic">哈基米遮罩探路.v8_CYBER</h1>
            {/* 新增的玩法说明 */}
            <div className="mb-4 text-cyan-500 text-xs tracking-widest opacity-80">
              <span className="bg-cyan-500 text-black px-2 py-0.5 mr-2 font-bold">MISSION</span>
              猫猫发射照明弹探路，没有被照明弹找到的区域将会变成虚空
            </div>
            <div className="flex gap-2">
              {[0, 1, 2].map(i => <div key={i} className={`h-1 w-12 ${i < probeCount ? 'bg-yellow-500 shadow-[0_0_15px_#eab308]' : 'bg-gray-900'}`} />)}
            </div>
            <span className="text-xs text-cyan-400">LEVEL_{state.current.level}</span>
          </div>
          <canvas ref={canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="bg-black border border-white/5 shadow-2xl" />
        </div>
      );
    };
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>

</html>